---
title: Quick Start
sidebar_label: Quick Start
---

This guide introduces the FoBE Breakout L76K and how to use it.

## Hardware diagram

The following figure illustrates the FoBE Breakout L76K hardware diagram.

<br/>
<div style={{ textAlign: 'center' }}>
  <img src="/img/products/f2207-r1a.digram.png" alt="FoBE Breakout L76K Hardware Diagram" style={{ width: '80%', height: 'auto' }} />
</div>
<br/>

## Mechanical dimensions

FoBE Breakout L76K is a single-sided 25.4mm x 25.4mm (1" x 1") 1.6mm thick PCB with a SH1.0 6-pin connector and a set of 6-pin 2.54mm header holes. Fixing by 4 x 1.6mm Screw holes.

<br/>
<div style={{ textAlign: 'center' }}>
  <img src="/img/products/f2207-r1a.dimensions.png" alt="FoBE Breakout L76K Mechanical Dimensions" style={{ width: '80%', height: 'auto' }} />
</div>
<br/>

## Interfaces
SH1.0 6Pin Connector and Reserved 6Pin Header Holes provide the following interfaces:

  |Interface                           |Description |
  |-------------------------------|---------|
  |3V3 |Power supply       |
  |GND  |Ground       |
  |TX |UART data output       |
  |RX |UART command input       |
  |RST |Reset IC, Low-active      |
  |WAKE |Enable IC's Standby mode, Low-active       |

## Configuration Jumper

The board features two jumper pads:

|Interface                           |Description |
|-------------------------------|---------|
|CONSTELLATION |Soldering this pad configures the module to use GPS + GLONASS. By default, the pad is not soldered, and the module uses BeiDou + GPS. |
|LED-JUMPER |The PPS (Pulse Per Second) LED jumper. To save power, you can physically cut the trace between the pads of this jumper. You can later re-solder the jumper to reconnect the PPS LED. |

## Other
- Build-in 3.1V Rechargeable Button Cell Battery for Data Retention.
- If using an active antenna, the "ACTIVE-ANT PWR" pad needs to be connected to 3V3.
- PPS-PULSE: Outputs a pulse per second, works concurrently with the PPS LED, but not affected by JP2.

## Programming

### Running with FoBE Quill ESP32S3 Mesh

Let's get started with the FoBE Quill ESP32S3 Mesh using the MFP interface.

1. Connect the FoBE Breakout L76K to the FoBE Quill ESP32S3 Mesh using the MFP interface.
<br/>
<div style={{ textAlign: 'center' }}>
  <img src="/img/products/f2207-r1a.connection.png" alt="FoBE Breakout L76K Connection" style={{ width: '80%', height: 'auto' }} />
</div>
<br/>

2. Create a sketch or PlatformIO project, or follow the [FoBE Quill ESP32S3 Programming Guide](/product/f1102/programming) for pre-configuration.

3. Install the necessary library in your project:
```ini
mikalhart/TinyGPSPlus@^1.1.0
```

4. Copy the following code into your sketch or PlatformIO project:
```cpp
#include <TinyGPSPlus.h>

#define GNSS_BAUD 9600          // GNSS module baud rate
#define GNSS_RX_PIN PIN_MFP1    // RX pin for GNSS communication, change if needed
#define GNSS_TX_PIN PIN_MFP2    // TX pin for GNSS communication, change if needed
#define GNSS_RST_PIN PIN_MFP3   // Reset pin for GNSS, change if needed
#define GNSS_WAKE_PIN PIN_MFP4  // Wake pin for GNSS, change if needed
#define PERI_EN_PIN PIN_PERI_EN // Peripheral enable pin, change if needed

TinyGPSPlus sensor;

// Buffer to store the latest NMEA sentence
String latestNmeaSentence = "";
char nmeaBuffer[128];
int bufferIndex = 0;

// Time tracking variables
unsigned long startupTime = 0;
unsigned long firstFixTime = 0;
bool firstFixAchieved = false;

void setup()
{
  // Initialize serial communication
  Serial.begin(115200);
  Serial.println("Serial initialized");

  // Initialize peripheral power
  if (PERI_EN_PIN >= 0)
  {
    pinMode(PERI_EN_PIN, OUTPUT);
    digitalWrite(PERI_EN_PIN, HIGH); // Enable peripheral power
    Serial.println("Peripheral power enabled");
  }

  // Initialize GNSS module (optional, if you want to test searching time cost)
  pinMode(GNSS_RST_PIN, OUTPUT);
  pinMode(GNSS_WAKE_PIN, OUTPUT);
  digitalWrite(GNSS_RST_PIN, LOW); // Reset the GNSS module
  delay(100);
  digitalWrite(GNSS_RST_PIN, HIGH);  // Release reset
  digitalWrite(GNSS_WAKE_PIN, HIGH); // Wake the GNSS module

  Serial1.begin(GNSS_BAUD, SERIAL_8N1, GNSS_RX_PIN, GNSS_TX_PIN);
  Serial.println("GNSS bus initialized");

  // Wait a moment for module to fully initialize
  delay(1000);

  // Record startup time
  startupTime = millis();
  Serial.printf("Startup time recorded: %lu ms\n", startupTime);

  // Wait for GNSS to be ready (equivalent to sensor init loop)
  Serial.println("Waiting for GNSS data...");
  unsigned long startTime = millis();
  while (millis() - startTime < 10000) // Wait up to 10 seconds
  {
    while (Serial1.available() > 0)
    {
      sensor.encode(Serial1.read());
    }
    if (sensor.location.isValid() || sensor.time.isValid() || sensor.satellites.value() > 0)
    {
      break;
    }
    delay(200);
  }
  Serial.println("GNSS sensor initialized");

  // Start measurement (GNSS automatically starts after initialization)
}

void loop()
{
  delay(100); // Wait equivalent to sensor.wait()

  // Read data from GNSS (equivalent to sensor.update())
  bool dataUpdated = false;
  while (Serial1.available() > 0)
  {
    char c = Serial1.read();

    // Build NMEA sentence buffer
    if (c == '$')
    {
      bufferIndex = 0;
      nmeaBuffer[bufferIndex++] = c;
    }
    else if (bufferIndex > 0 && bufferIndex < 127)
    {
      nmeaBuffer[bufferIndex++] = c;
      if (c == '\n')
      {
        nmeaBuffer[bufferIndex] = '\0';
        latestNmeaSentence = String(nmeaBuffer);
      }
    }

    if (sensor.encode(c))
    {
      dataUpdated = true;
    }
  }

  if (dataUpdated) // Equivalent to sensor.update() == RESULT_OK
  {
    if (sensor.location.isValid() || sensor.time.isValid()) // Equivalent to sensor.hasNewData()
    {
      // Check for first fix achievement
      if (!firstFixAchieved && sensor.location.isValid())
      {
        firstFixTime = millis();
        firstFixAchieved = true;
      }

      // Display data on screen
      Serial.print("\033[H\033[J");
      Serial.println("> FoBE Breakout L76K Monitor");
      Serial.println();
      Serial.print("\033[7m");
      Serial.printf("%-12s%-12s%-12s\n", "INDEX", "VALUE", "UNIT");
      Serial.print("\033[0m");

      if (sensor.location.isValid())
      {
        Serial.printf("%-12s%-12.6f%-12s\n", "LATITUDE", sensor.location.lat(), "째");
        Serial.printf("%-12s%-12.6f%-12s\n", "LONGITUDE", sensor.location.lng(), "째");
      }

      if (sensor.altitude.isValid())
      {
        Serial.printf("%-12s%-12.2f%-12s\n", "ALTITUDE", sensor.altitude.meters(), "m");
      }

      if (sensor.speed.isValid())
      {
        Serial.printf("%-12s%-12.2f%-12s\n", "SPEED", sensor.speed.kmph(), "km/h");
      }

      if (sensor.satellites.isValid())
      {
        Serial.printf("%-12s%-12d%-12s\n", "SATELLITES", sensor.satellites.value(), "");
      }

      if (sensor.hdop.isValid())
      {
        Serial.printf("%-12s%-12.2f%-12s\n", "HDOP", sensor.hdop.hdop(), "");
      }

      // Add GPS time display
      if (sensor.time.isValid() && sensor.date.isValid())
      {
        Serial.printf("%-12s%02d:%02d:%02d%-12s\n", "TIME", sensor.time.hour(), sensor.time.minute(), sensor.time.second(), "UTC");
        Serial.printf("%-12s%04d-%02d-%02d%-12s\n", "DATE", sensor.date.year(), sensor.date.month(), sensor.date.day(), "");
      }

      // Add Time to First Fix Information
      if (firstFixAchieved)
      {
        unsigned long timeToFirstFix = firstFixTime - startupTime;
        Serial.printf("%-12s%-12.3f%-12s\n", "TTFF", timeToFirstFix / 1000.0, "SEC");
      }
      else
      {
        unsigned long currentTime = millis();
        unsigned long timeElapsed = currentTime - startupTime;
        Serial.printf("%-12s%-12.3f%-12s\n", "SEARCHING", timeElapsed / 1000.0, "SEC");
      }

      // Print latest NMEA data stream below the table
      Serial.println();
      Serial.println("Latest NMEA Data Stream:");
      if (latestNmeaSentence.length() > 0)
      {
        Serial.print(latestNmeaSentence);
      }
      else
      {
        Serial.println("No NMEA data received yet");
      }
    }
  }
}
```

:::important
This example code uses ANSI output formatting. Your terminal must support ANSI escape codes to display the output correctly.

```ini
# platformio.ini
[env:fobe_quill_esp32s3_mesh]
platform = FoBE Espressif 32
board = fobe_quill_esp32s3_mesh
framework = arduino
lib_deps = 
	mikalhart/TinyGPSPlus@^1.1.0
monitor_speed = 115200
monitor_raw = true
```
:::

5. Build and upload the project. You should see the FoBE Breakout L76K Monitor output in the serial monitor (raw mode).

```bash
> FoBE Breakout L76K Monitor

INDEX       VALUE       UNIT        
LATITUDE    22.123456   째          
LONGITUDE   114.123456  째          
ALTITUDE    71.20       m           
SPEED       17.33       km/h        
SATELLITES  15                       
HDOP        24.80                   
TIME        19:59:03UTC         
DATE        2025-08-08            
TTFF        3.236       SEC         

Latest NMEA Data Stream:
$GNGSA,A,1,,,,,,,,,,,,,25.5,24.8,25.5,1*0D                
```